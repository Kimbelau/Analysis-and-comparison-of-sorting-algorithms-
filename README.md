Существует большое количество различных алгоритмов сортировки, таких как сортировка пузырьком, сортировка вставками, сортировка выбором, сортировка слиянием, быстрая сортировка и другие. Каждый из этих алгоритмов имеет свои особенности, сложность и время работы, а также эффективность в различных условиях.

**Целью данной работы** является проведение анализа и сравнение различных алгоритмов сортировки с целью выявления их эффективности, а именно сравнение затраченного времени на выполнение сортировки для разных входных объёмов данных.

**Задачи** для достижения поставленной цели:

1. Изучить основные математические определения и термины.
2. Провести обзор основных алгоритмов сортировки.
3. Провести анализ времени работы различных алгоритмов сортировки на различных наборах данных.
4. Сравнить с использованием математических методов полученные значения и теоретические.

В рамках данной работы будут использованы математические методы анализа, такие как оценка сложности алгоритмов, расчет времени выполнения, а также методы для сравнения и анализа эффективности различных алгоритмов сортировки.

**Объектом исследования** являются алгоритмы сортировок.

**Предметом исследования** являются сортировка вставкой, выбором, пузырьком, кучей и быстрая сортировка, а также их анализ, моделирование и сравнение.

---

## **Глава 1. Теоретические основы анализа алгоритмов и описание алгоритмов сортировки**

### **1.1 Теория анализа временной и пространственной сложности алгоритмов**

Теория анализа временной и пространственной сложности алгоритмов изучает, какие ресурсы (время и память) требуются для выполнения различных алгоритмов. Для анализа сложности алгоритмов используются различные функции и математические определения.

Временная сложность алгоритма определяет количество времени, необходимое для выполнения алгоритма в зависимости от размера входных данных. Одной из основных функций, используемой для измерения временной сложности, является функция f(n), где n — размер входных данных, а f(n) — количество операций, выполненных алгоритмом. Асимптотический анализ позволяет определить рост функции f(n) при увеличении размера входных данных. Для измерения пространственной сложности используется функция g(n), где g(n) — количество памяти, занимаемой алгоритмом.

Существуют такие основные классы асимптотической сложности, как O-обозначение, Ω-обозначение и Θ-обозначение.

- **O-обозначение** («О-большое») используется для оценки верхней границы роста функции f(n) и обозначает, что f(n) растет не быстрее определенной функции g(n).
- **Ω-обозначение** («омега-большое») используется для оценки нижней границы роста функции f(n) и обозначает, что f(n) растет не медленнее определенной функции g(n).
- **Θ-обозначение** («тета-большое») используется для оценки точной асимптотики функции f(n) и обозначает, что f(n) растет пропорционально g(n).

Оценка сложности алгоритмов позволяет выбирать наиболее эффективные алгоритмы для решения конкретных задач в зависимости от возможностей компьютерной системы, объема входных данных и других факторов, а также позволяет более эффективно управлять используемыми ресурсами и избегать проблем, связанных с избыточным использованием памяти.

Для анализа временной сложности алгоритмов также важно учитывать лучший, худший и средний случаи выполнения алгоритма в зависимости от входных данных и их распределения.

---

### **1.2 Описание и анализ алгоритмов сортировки**

### **• Алгоритм сортировки вставками**

**Сортировка вставками** — простой алгоритм сортировки, хотя менее эффективный, чем, например, быстрая сортировка. Однако у него есть ряд преимуществ: эффективность на небольших наборах данных; эффективность на уже отсортированных частично данных; устойчивость (сохранение порядка) отсортированных элементов; возможность сортировки списка по мере его получения.

**Описание алгоритма:** на каждом шаге выбирается один из элементов входных данных и вставляется на нужную позицию в уже отсортированном списке, повторяется до полного исчерпания входных данных.

**Реализация на C#:**
```csharp
static private void Insertionsort(List<int> vec, int n)
{
    for (int i = 0; i < n; i++)
    {
        int j = i;
        while (j > 0 && vec[j - 1] > vec[j])
        {
            (vec[j - 1], vec[j]) = (vec[j], vec[j - 1]);
            j--;
        }
    }
}
```
**Анализ алгоритма**: временная сложность алгоритма при худшем варианте входных данных — Θ(n²), а в лучшем случае время работы алгоритма составляет Θ(n). Пространственная сложность равна O(1).


### **• Пузырьковая сортировка**

**Сортировка пузырьком**, также известная как сортировка простыми обменами, представляет собой простой алгоритм сортировки. Он эффективен лишь для небольших массивов.

**Описание алгоритма:** весь процесс заключается в многократных проходах по сортируемому массиву. На каждом проходе элементы последовательно сравниваются попарно. Если порядок элементов в паре неверный, то выполняется обмен элементов.

**Реализация на C#:**

```csharp
static private void Bubblesort(List<int> vec, int n)
{
    int f = 1;
    while (f == 1)
    {
        f = 0;
        for (int i = 0; i < n - 1; i++)
        {
            if (vec[i] > vec[i + 1])
            {
                (vec[i], vec[i + 1]) = (vec[i + 1], vec[i]);
                f = 1;
            }
        }
        n--;
    }
}
```
**Анализ алгоритма:** временная сложность составляет Θ(n²) всегда. Пространственная сложность равна O(1).


### **• Быстрая сортировка**

**Быстрая сортировка** считается наиболее быстрой и эффективной в большинстве случаев. Вся суть заключается в разделении и рекурсии.

**Описание алгоритма:** Выбирается опорный элемент, после чего все элементы, меньшие его, перемещаются налево, а большие — направо. Процесс повторяется рекурсивно для каждой из частей.

**Реализация на C#:**

```csharp
static private int Partition(List<int> vec, int p, int r)
{
    var support = vec[r];
    int i = p;
    for (int j = p; j < r; ++j)
    {
        if (vec[j] <= support)
        {
            (vec[i], vec[j]) = (vec[j], vec[i]);
            ++i;
        }
    }
    (vec[i], vec[r]) = (vec[r], vec[i]);
    return i;
}

static private void Quicksort(List<int> vec, int start, int end)
{
    if (start < end)
    {
        int pivot = Partition(vec, start, end);
        Quicksort(vec, start, pivot - 1);
        Quicksort(vec, pivot + 1, end);
    }
}
```
**Анализ алгоритма:** Θ(n log n) в среднем и лучшем случае, Θ(n²) в худшем случае.


### **• Сортировка выбором**

**Сортировка выбором** является простой и эффективной для выполнения нужных задач.

**Описание алгоритма:** Находим минимальное значение в текущем списке, производим обмен этого значения со значением на первой неотсортированной позиции, затем сортируем хвост списка, исключив из рассмотрения уже отсортированные элементы.

**Реализация на C#:**

```csharp
static private void SelectionSort(List<int> vec, int n)
{
    for (int i = 0; i < n; ++i)
    {
        var index_of_min = i;
        for (int j = i + 1; j < n; ++j)
        {
            if (vec[j] < vec[index_of_min]) index_of_min = j;
        }
        (vec[i], vec[index_of_min]) = (vec[index_of_min], vec[i]);
    }
}
```
**Анализ производительности:** время работы алгоритма не зависит от начального расположения элементов в массиве. Во всех случаях будет Θ(n²).


### **• Сортировка кучей**

**Сортировка кучей** является сложнее, чем все сортировки выше, однако она значительно быстрее почти всех.

**Описание алгоритма:** Идея заключается в том, чтобы представить изначальный массив данных как почти полное бинарное дерево (кучу). Самый большой элемент пирамиды находится в её вершине. Отделяем вершинный элемент и записываем его в конец результирующего массива, затем восстанавливаем кучу.

**Реализация на C#:**

```csharp
static private void heapify(List<int> vec, int n, int i)
{
    int largest = i;
    int l = 2 * i + 1;
    int r = 2 * i + 2;
    if (l < n && vec[l] > vec[largest])
        largest = l;
    if (r < n && vec[r] > vec[largest])
        largest = r;
    if (largest != i)
    {
        (vec[i], vec[largest]) = (vec[largest], vec[i]);
        heapify(vec, n, largest);
    }
}

static private void HeapSort(List<int> vec, int n)
{
    for (int i = n / 2 - 1; i >= 0; i--)
        heapify(vec, n, i);
    for (int i = n - 1; i >= 0; i--)
    {
        (vec[0], vec[i]) = (vec[i], vec[0]);
        heapify(vec, i, 0);
    }
}
```
**Анализ производительности:** время работы алгоритма равно O(n log n), дополнительной памяти задействовано O(1).


## **Глава 2. Экспериментальный анализ алгоритмов сортировки**

### **2.1 Моделирование работы алгоритмов сортировки**

Для моделирования работы различных алгоритмов сортировки использовался язык программирования C#. Для построения графика был использован язык программирования Python 3.

При запуске программы графический интерфейс предлагает 4 варианта возможных действий:

Протестировать все алгоритмы сортировок.

Загрузить уже сохраненный ранее файл.

Сохранить данные результаты.

Построить графики на основе результатов сортировок.

Пример работы:
![](misk/image1/12.png)

### **2.2 Анализ и сравнение результатов работы алгоритмов сортировки**
После окончания работы сортировок получаем таблицу с временем работы каждой из сортировок в миллисекундах. В левом столбце по возрастанию указано количество элементов.

![](misk/image1/13.png)

Проанализировав время работы алгоритмов, можно упорядочить алгоритмы сортировки по возрастанию эффективности:

Быстрая сортировка

Сортировка кучей

Сортировка вставкой

Сортировка выбором

Пузырьковая сортировка

Таблица теоретической временной сложности алгоритмов:

Алгоритм	Худший случай	Средний случай	Лучший случай
Пузырьковая сортировка	O(n²)	O(n²)	O(n²)
Сортировка вставкой	O(n²)	O(n²)	O(n)
Сортировка кучей	O(n log n)	O(n log n)	O(n log n)
Быстрая сортировка	O(n²)	O(n log n)	O(n log n)
Сортировка выбором	O(n²)	O(n²)	O(n²)
Исходя из полученных данных видно, что медленные сортировки (пузырьком, выбором, вставкой) сильно проигрывают по эффективности быстрым сортировкам (кучей, быстрая сортировка). Это соответствует теоретическому анализу данных сортировок.

## **Заключение**
В рамках данной курсовой работы была представлена теория по данной теме, сделан анализ алгоритмов сортировки, и были выполнены их построение с помощью кода и их тестирование. Были исследованы такие алгоритмы сортировки, как сортировка вставкой, сортировка выбором, пузырьковая сортировка, сортировка кучей и быстрая сортировка. Мы построили графики зависимости времени сортировки от количества сортируемых элементов и сравнили эффективность этих алгоритмов друг с другом. Полученные результаты были сравнены с теоретическими оценками времени выполнения алгоритмов.

По результатам тестирования самым эффективным алгоритмом сортировки оказалась быстрая сортировка, а самым медленным — сортировка вставкой. Это согласуется с теоретическими предсказаниями по поводу производительности этих алгоритмов.

## **Список литературы**
Бхаргава А. Грокаем алгоритмы. Иллюстративное пособие для программистов и любопытствующих. — СПб. : Питер, 2022. — 288 с. : ил. — (Серия «Библиотека программиста») ISBN 978-5-4461-0923-4.

А. Н. Коварцев, А. Н. Даниленко. АЛГОРИТМЫ И АНАЛИЗ СЛОЖНОСТИ. Учебник. Самара: Изд-во Самарского университета, 2018. — 128 с.: ил.

## **Приложения**
Приложение 1

![](misk/image1/14.png)

Приложение 2

![](misk/image1/15.png)

Приложение 3

![](misk/image1/16.png)
